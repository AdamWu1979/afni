import attr
from .utils.misc import is_omp
import pytest
from .utils import tools
from pathlib import Path
import shutil
import datetime as dt
from datalad import api as datalad
import os


def make_pretend_repo(dirname):
    os.chdir(dirname)
    datalad.rev_create(Path.cwd(), force=True)
    rev_log = datalad.rev_save(dirname, "add data")
    (dirname / "useless.txt").write_text("who me.")
    datalad.rev_save(dirname, "add superfluous change")
    (dirname / "useless.txt").unlink()
    datalad.rev_save(dirname, "make things better")


def create_data_dir(dirname):
    tooldir = dirname / "toolname"
    tooldir.mkdir()
    testdir = tooldir / "test_function_name"
    testdir.mkdir()
    logdir = testdir / "captured_output"
    logdir.mkdir()

    sample_text = """
        The following lines should be part of a comparison for text files but not logs:
        AFNI version=
        Clock time now
        elapsed time
        auto-generated by
        CPU time =

        Some more text in the file...
        """
    # Write some logs and a text file
    stdout = logdir / (testdir.name + "_stdout.log")
    stdout.write_text(sample_text)
    Path(str(stdout).replace("stdout", "stderr")).write_text(sample_text)
    (testdir / "sample_text.txt").write_text(sample_text)


@pytest.fixture(scope="session")
def mock_data_orig(tmp_path_factory):
    orig_name = tmp_path_factory.mktemp(tools.get_output_name())
    create_data_dir(orig_name)
    make_pretend_repo(orig_name)
    tools.remove_w_perms(orig_name)
    return orig_name


@pytest.fixture(scope="session")
def get_mock_data(tmp_path_factory, mock_data_orig):
    tmpdirs = []

    def _get_mock_data():

        tmpdir = tmp_path_factory.mktemp(tools.get_output_name())
        create_data_dir(tmpdir)
        tmpdirs.append(tmpdir)

        tname = "test_function_name"
        test_comparison_dir = mock_data_orig / "toolname" / tname
        outdir = tmpdir / "toolname" / tname

        out_dict = {}
        out_dict.update(
            {
                "module_outdir": outdir.parent,
                "outdir": outdir,
                "sampdir": tools.convert_to_sample_dir_path(tmpdir),
                "logdir": outdir / "captured_output",
                "comparison_dir": test_comparison_dir,
                "base_comparison_dir": mock_data_orig,
                "base_outdir": tmpdir,
                "test_name": tname,
            }
        )

        DataClass = attr.make_class(
            tname + "_data", [k for k in out_dict.keys()], slots=True
        )
        data = DataClass(*[v for v in out_dict.values()])

        return tmpdir, data

    yield _get_mock_data

    for tmp_data_dir in tmpdirs:
        shutil.rmtree(tmp_data_dir)


# @pytest.fixture(scope="function")
# def output_mock(output_mock_orig):
#     outdir = output_mock_orig.with_name(tools.get_current_test_name() + "_0")
#     while outdir.exists():
#         parts = outdir.name.rsplit("_", 1)
#         new = int(parts[1]) + 1
#         outdir = outdir.parent / f"{parts[0]}_{new}"

#     shutil.copytree(output_mock_orig, outdir, symlinks=True)
#     return outdir


@pytest.mark.slow
def test_diffs_detected(get_mock_data, mock_data_orig):

    output_mock, data = get_mock_data()
    differ = tools.OutputDiffer(data, "echo hello")
    differ.get_file_list()
    differ.assert_all_files_equal()


# @pytest.fixture()
# def comparison_dir_factory():


# @pytest.fixture()
# def mock_test_data_dir():
#     pass


# @pytest.fixture()
# def mock_test_outdir_matching():
#     pass


# @pytest.fixture()
# def mock_test_outdir_diffs():
#     pass


# @pytest.fixture()
# def mock_test_outdir_should_fail():
#     pass


# @pytest.fixture()
# def mock_test_outdir_does_not_exist():
#     pass


# from pathlib import Path

# from john_run_algo.utils import data_management


# def fake_storage():

#     print("executing fake_storage")
#     return Path("goodbye")


# def test_check_data_store(mocker):

#     mocker.patch(
#         "john_run_algo.utils.data_management.get_storage_dir",
#         return_value=Path("return_value"),
#     )
#     data_management.check_data_store("m_end", ["symbol"])
#     assert False


# # check for omp compilation
# OMP = is_omp("3dAllineate")


# # Define Data
# data_paths = {
#     "anat1": "mini_data/anat_3mm_no_skull.nii.gz",
#     "epi": "AFNI_data6/afni/epi_r1+orig.BRIK",
#     "epi_head": "AFNI_data6/afni/epi_r1+orig.HEAD",
# }


# # TESTS:
# @pytest.mark.slow
# @pytest.mark.skip(
#     reason="Not sure how to handle difference in output between osx and linux."
# )
# def test_3dAllineate_basic(data, python_interpreter):
#     outname = "aligned"
#     if OMP:
#         outname += "_with_omp"
#     outfile = data.outdir / (outname + ".nii.gz")
#     out_1d = outfile.parent / (outfile.stem.split(".")[0] + ".1D")

#     cmd = """
#     3dAllineate
#         -base {data.anat1}
#         -source {data.epi}'[0]'
#         -prefix {outfile}
#         -1Dparam_save {out_1d}
#         -maxrot 2
#         -maxshf 1
#         -nmatch 20
#         -conv 2
#         -cost lpc
#     """
#     cmd = " ".join(cmd.format(**locals()).split())

#     # Run command and test all outputs match
#     differ = tools.OutputDiffer(
#         data,
#         cmd,
#         python_interpreter=python_interpreter,
#         kwargs_log={
#             "append_to_ignored": [
#                 "Output dataset",
#                 "++ Wrote -1Dparam_save",
#                 "total CPU time",
#             ]
#         },
#     )
#     differ.run()
